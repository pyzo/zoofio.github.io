<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Zoof UI</title>
    <style>/* ========== Preparations ========== */

html {
    /* set height, so body can have height, and the first layout too */
    height: 100%;  
}

body {
    /* Set height so the first layout can fill whole window */
    height: 100%;
    margin: 0px;
}


/* ========== Layout ========== */

.zf-layout {
    width: 100%;
    height: 100%;
    margin: 0px;
    padding: 0px;
    border-spacing: 0px;
    border: 0px;
}

.hcell .vcell {
    /* inter-widget spacing. padding-left/top is set to "spacing"
       on each non-first row/column in the layout. */
    padding: 0px;  
}


.zf-pinboard {
    position: relative;
}


/* ========== Widgets in a layout ========== */

/* In flexed cells, occupy the full space */
td.vflex > .zf-widget {
    height: 100%;
}
td.hflex > .zf-widget {
    width: 100%;
}


.zf-pinboard > .zf-widget {
    position: absolute;
}


.zf-form > tr > td > .zf-label {
    text-align: right;
}

/* ========== Widgets ========== */

.zf-widget {
    box-sizing: border-box;
    white-space: nowrap;
    overflow: hidden;
}

.zf-label {
    /*background: #aaa;*/
}

/* ========== Appearance ========== */

body {
    background-color: #eee;
}

/*
.zf-hbox > tr > td {
   border: 1px solid red;
}
.zf-vbox > tr > td { 
    border: 1px solid blue;
}
/**/</style>
</head>

<body id='body'>
    <script>
        // Init zoof namespace
        window.zoof = {};
        zoof.ws = null;
        zoof.isExported = true;
        
        zoof.runExportedApp = function () {
            zoof.command('ICON 7f09de2a1470.ico');
            zoof.command('TITLE Zoof app');
            zoof.command('EXEC zoof.createHBox({"margin": "0px", "hflex": 0, "className": "zf-hbox zf-layout zf-widget", "id": "HBox1", "vflex": 0, "parent": "body", "pos": [0, 0], "spacing": "0px"});');
            zoof.command('EXEC zoof.setProps("HBox1", "flex", (0, 0));');
            zoof.command('EXEC zoof.createButton({"hflex": 0, "className": "zf-button zf-widget", "id": "Button2", "vflex": 0, "parent": "HBox1", "pos": [0, 0], "text": "Box A"});');
            zoof.command('EXEC zoof.setProps("Button2", "flex", (0, 0));');
            zoof.command('EXEC zoof.createButton({"hflex": 0, "className": "zf-button zf-widget", "id": "Button3", "vflex": 0, "parent": "HBox1", "pos": [0, 0], "text": "Box B"});');
            zoof.command('EXEC zoof.setProps("Button3", "flex", (0, 0));');
            zoof.command('EXEC zoof.createButton({"hflex": 0, "className": "zf-button zf-widget", "id": "Button4", "vflex": 0, "parent": "HBox1", "pos": [0, 0], "text": "Box C is a bit longer"});');
            zoof.command('EXEC zoof.setProps("Button4", "flex", (0, 0));');
            zoof.command("EXEC zoof.get('HBox1').applyLayout();");
        };
    </script>
    <script>/*jslint browser: true, node: true, continue:true bitwise: true */
"use strict";

function decodeUtf8(arrayBuffer) {
    var result = "",
        i = 0,
        c = 0,
        c1 = 0,
        c2 = 0,
        c3 = 0,
        data = new window.Uint8Array(arrayBuffer);

    // If we have a BOM skip it
    if (data.length >= 3 && data[0] === 0xef && data[1] === 0xbb && data[2] === 0xbf) {
        i = 3;
    }

    while (i < data.length) {
        c = data[i];

        if (c < 128) {
            result += String.fromCharCode(c);
            i += 1;
        } else if (c > 191 && c < 224) {
            if (i + 1 >= data.length) {
                throw "UTF-8 Decode failed. Two byte character was truncated.";
            }
            c2 = data[i + 1];
            result += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
            i += 2;
        } else {
            if (i + 2 >= data.length) {
                throw "UTF-8 Decode failed. Multi byte character was truncated.";
            }
            c2 = data[i + 1];
            c3 = data[i + 2];
            result += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
            i += 3;
        }
    }
    return result;
}
</script>
    <script>/*
    Main script for zoof.js
*/

/* JSLint config */
/*global zoof, decodeUtf8 */
/*jslint browser: true, node: true, continue:true */
"use strict";



zoof.init = function () {
    if (zoof.isExported) {
        zoof.runExportedApp();
    } else {
        zoof.initSocket();
        zoof.initLogging();
    }    
};


zoof.exit = function () {
    if (zoof.ws) {
        zoof.ws.close();
    }
};


window.addEventListener('load', zoof.init, false);
window.addEventListener('beforeunload', zoof.exit, false);


zoof.command = function (msg) {
    var log, link;
    log = document.getElementById('log');
    if (msg.search('EVAL ') === 0) {
        /*jslint nomen: true, evil: true*/
        window._ = eval(msg.slice(5));
        zoof.ws.send('RET ' + window._);  // send back result

    } else if (msg.search('EXEC ') === 0) {
        /*jslint nomen: true, evil: true*/
        eval(msg.slice(5));  // like eval, but do not return result
        /*jslint nomen: false, evil: false*/
    } else if (msg.search('TITLE ') === 0) {
        document.title = msg.slice(6);
    } else if (msg.search('ICON ') === 0) {
        link = document.createElement('link');
        link.rel = 'icon';
        link.href = msg.slice(5);
        document.getElementsByTagName('head')[0].appendChild(link);
    } else if (msg.search('OPEN ') === 0) {
        window.win1 = window.open(msg.slice(5), 'new', 'chrome');
    } else {
        log.innerHTML += msg + "<br />";
    }
};


zoof.initSocket = function () {
    var loc, url, ws;
    
    zoof.lastmsg = null;
    
    // Check WebSocket support
    if (window.WebSocket === undefined) {
        document.body.innerHTML = 'This browser does not support WebSockets';
        return;
    }
    
    // Open web socket in binary mode
    loc = location;
    url = "ws://" + loc.hostname + ':' + loc.port + "/" + loc.pathname + "/ws";
    ws = new window.WebSocket(url);
    zoof.ws = ws;
    ws.binaryType = "arraybuffer";
    
    ws.onmessage = function (evt) {
        var msg;
        zoof.lastmsg = evt.data;
        msg = decodeUtf8(evt.data);
        zoof.command(msg);
    };
    
    ws.onclose = function (ev) {
        document.body.innerHTML = 'Lost connection with GUI server:<br >';
        document.body.innerHTML += ev.reason + " (" + ev.code + ")";
    };
    
    ws.onopen = function (ev) {
        var log = document.getElementById('log');
        log += 'Socket connected' + "<br />";
    };
    
    ws.onerror = function (ev) {
        var log = document.getElementById('log');
        log.innerHTML += 'Socket error' + ev.error + "<br />";
    };
};


zoof.initLogging = function () {
    var errorHandler;
    
    // Keep originals
    console.ori_log = console.log;
    console.ori_info = console.info || console.log;
    console.ori_warn = console.warn || console.log;
    
    // Set new functions
    console.log = function (msg) {
        zoof.ws.send("INFO " + msg);
        console.ori_log(msg);
    };
    console.info = function (msg) {
        zoof.ws.send("INFO " + msg);
        console.ori_info(msg);
    };
    console.warn = function (msg) {
        zoof.ws.send("WARN " + msg);
        console.ori_warn(msg);
    };
    
    // Create error handlers, so that JS errors get into Python
    window.addEventListener('error', errorHandler, false);
    
    errorHandler = function (ev) {
        // ev: message, url, linenumber
        var intro = "On line " + ev.lineno + " in " + ev.filename + ":";
        zoof.ws.send("ERROR " + intro + '\n    ' + ev.message);
    };
};
</script>
    <script>/*  Script for handling widgets and layout.

*/

/* JSLint config */
/*global zoof */
/*jslint node: true, continue:true */
"use strict";

zoof.widgets = {};
zoof.AUTOFLEX = 729;  // magic number unlikely to occut in practice


zoof.get = function (id) {
    if (id === 'body') {
        return document.body;
    } else {
        return zoof.widgets[id];
    }
};


zoof.createWidgetElement = function (type, D) {
    /* Used by all createX functions to create the HTML element, assign
       id and class name, and insert the element in the DOM.
    */
    var e = document.createElement(type),
        par;  // semantic parent
    
    e.id = D.id;
    zoof.widgets[D.id] = e;
    
    e.className = D.className;
    e.hflex = D.hflex;
    e.vflex = D.vflex;
    e.zfInfo = D;  // store info used to create the widget
    
    // Set position. Ignored unless position is absolute or relative
    e.style.left = (D.pos[0] > 1 ? D.pos[0] + "px" : D.pos[0] * 100 + "%");
    e.style.top = (D.pos[1] > 1 ? D.pos[1] + "px" : D.pos[1] * 100 + "%");
    
    // Add to parent
    par = zoof.get(D.parent);
    if (typeof par.appendWidget === 'function') {
        par.appendWidget(e);
    } else {
        par.appendChild(e);
    }
    
    // Add callback for resizing    
    e.checkResize = function () {
        /* This needs to be called if there is a chance that the widget has
           changed size. If will check the real size the next tick and emit
           a resize event if necessary.
        */
        setTimeout(e.checkResizeNow, 0);
    };
    e.storedSize = [0, 0];
    e.checkResizeNow = function () {
        var i, func, event;
        event = new window.CustomEvent("resize");
        event.widthChanged = (e.storedSize[0] !== e.clientWidth);
        event.heightChanged = (e.storedSize[1] !== e.clientHeight);
        if (event.widthChanged || event.heightChanged) {
            e.storedSize = [e.clientWidth, e.clientHeight];
            e.dispatchEvent(event);
        }
    };
        
    // Always invoke a resize after all initialization is done
    e.checkResize();
    // Keep up to date from parent size changes    
    if (par === document.body) {
        window.addEventListener('resize', e.checkResize, false);
    } else {
        par.addEventListener('resize', e.checkResize, false);
    }
            
    return e;
};


zoof.setProps = function (id) {
    var i,
        e = zoof.get(id);
    for (i = 0; i < arguments.length; i += 2) {
        e[arguments[i]] = arguments[i + 1];
    }
};

zoof.setStyle = function (id) {
    var i,
        e = zoof.get(id);
    for (i = 1; i < arguments.length; i += 2) {
        e.style[arguments[i]] = arguments[i + 1];
    }
};


zoof.createWidget = function (D) {
    var e = zoof.createWidgetElement('div', D);
};


zoof.createLabel = function (D) {
    var e = zoof.createWidgetElement('div', D);
    e.innerHTML = D.text;
};


zoof.createButton = function (D) {
    var e = zoof.createWidgetElement('button', D);
    e.innerHTML = D.text;
};


zoof.createHBox = function (D) {
    var e, row;
    
    e = zoof.createWidgetElement('table', D);
    row = document.createElement("tr");
    e.appendChild(row);
        
    // layout margin is implemented by table padding
    e.style.padding = D.margin;
    
    e.appendWidget = function (child) {
        var td = document.createElement("td");
        row.appendChild(td);
        td.appendChild(child);
        if (row.children.length > 1) {
            td.style['padding-left'] = D.spacing;
        }
    };
    
    e.applyLayout = function () {zoof.applyTableLayout(this); };
    
    e.applyCellLayout = function (row, col, vflex, hflex, cum_vflex, cum_hflex) {
        col.style.height = '100%';
        if (hflex === 0) {
            col.className = '';
            col.style.width = 'auto';
        } else {
            col.className = 'hflex';
            col.style.width = hflex * 100 / cum_hflex + '%';
        }
    };
    
    // no need to adjust the row-height when resizing
};


zoof.createVBox = function (D) {
    var e = zoof.createWidgetElement('table', D);
    
    e.appendWidget = function (child) {
        var tr = document.createElement("tr"),
            td = document.createElement("td");
        this.appendChild(tr);
        tr.appendChild(td);
        td.appendChild(child);
    };
    
    e.applyLayout = function () {zoof.applyTableLayout(this); };
    
    e.applyCellLayout = function (row, col, vflex, hflex, cum_vflex, cum_hflex) {
        
        row.vflex = vflex;
        if (vflex === 0) {
            col.className = 'hflex';
            row.style.height = 'auto';
        } else {
            col.className = 'vflex hflex';
            row.style.height = vflex * 100 / cum_vflex + '%';
        }
    };
    
    // We need to adjust height-percent when there is a vertical resize
    e.addEventListener('resize', zoof.adaptLayoutToSizeChange, false);
};


zoof.createForm = function (D) {
    var e = zoof.createWidgetElement('table', D);
    e.appendChild(document.createElement("tr"));
    
    e.appendWidget = function (child) {
        var row, td, itemsinrow;
        row = e.children[e.children.length - 1];
        itemsinrow = row.children.length;
        if (itemsinrow >= 2) {
            row = document.createElement("tr");
            e.appendChild(row);
        }
        td = document.createElement("td");
        row.appendChild(td);
        td.appendChild(child);
        // Do some auto-flexing
        child.hflex = (row.children.length === 1 ? 0 : 1);
    };
    
    e.applyLayout = function () {zoof.applyTableLayout(this); };
    
    e.applyCellLayout = function (row, col, vflex, hflex, cum_vflex, cum_hflex) {
        var className = '';
        if ((vflex === zoof.AUTOFLEX) || (vflex === 0)) {
            row.style.height = 'auto';
            className += '';
        } else {
            row.style.height = vflex * 100 / cum_vflex + '%';
            className += 'vflex';
        }
        className += ' ';
        if (hflex === 0) {
            col.style.width = 'auto';
            className += '';
        } else {
            col.style.width = '100%';
            className += 'hflex';
        }
        col.className = className;
    };
    
    // We need to adjust height-percent when there is a vertical resize
    e.addEventListener('resize', zoof.adaptLayoutToSizeChange, false);
};


zoof.createGrid = function (D) {
    var e = zoof.createWidgetElement('table', D);
    e.appendChild(document.createElement("tr"));
    
    e.appendWidget = function (child) {
        var i, j, row, cell;
        i = child.zfInfo.pos[1];
        j = child.zfInfo.pos[0];
        // Ensure enough rows
        while (i >= e.children.length) {
            e.appendChild(document.createElement("tr"));
        }
        row = e.children[i];
        // Ensure enough coloums
        while (j >= row.children.length) {
            row.appendChild(document.createElement("td"));
        }
        cell = row.children[j];
        // Append
        cell.appendChild(child);
    };
    
    e.applyLayout = function () {zoof.applyTableLayout(this); };
    
    e.applyCellLayout = function (row, col, vflex, hflex, cum_vflex, cum_hflex) {
        var className = '';
        if (vflex === 0) {
            row.style.height = 'auto';
            className += '';
        } else {
            row.style.height = vflex * 100 / cum_vflex + '%';
            className += 'vflex';
        }
        className += ' ';
        if (hflex === 0) {
            col.style.width = 'auto';
            className += '';
        } else {
            col.style.width = hflex * 100 / cum_hflex + '%';
            className += ' hflex';
        }
        col.className = className;
    };
    
    // We need to adjust height-percent when there is a vertical resize
    e.addEventListener('resize', zoof.adaptLayoutToSizeChange, false);

};


zoof.createPinBoard = function (D) {
    var e = zoof.createWidgetElement('div', D);
    e.applyLayout = function () {}; // dummy    
};


zoof.applyTableLayout = function (table) {
    /* To be called with a layout id when a child is added or stretch factor
       changes. Calculates the flexes and (via a layout-dependent function)
       sets the class of the td element and the width of the td element.
       The heights of tr elements is set on resize, since it behaves slightly 
       different.
    */
    var row, col,
        i, j, nrows, ncols,
        vflexes, hflexes, cum_vflex, cum_hflex;
        
    // Get table dimensions    
    nrows = table.children.length;
    ncols = 0;
    for (i = 0; i < nrows; i += 1) {
        row = table.children[i];
        ncols = Math.max(ncols, row.children.length);
    }
    if (nrows === 0 || ncols === 0) {
        return;
    }
    
    // Collect flexes
    vflexes = [];
    hflexes = [];
    for (i = 0; i < nrows; i += 1) {
        row = table.children[i];
        for (j = 0; j < ncols; j += 1) {
            col = row.children[j];
            if ((col === undefined) || (col.children.length === 0)) {
                continue;
            }
            vflexes[i] = Math.max(vflexes[i] || 0, col.children[0].vflex || 0);
            hflexes[j] = Math.max(hflexes[j] || 0, col.children[0].hflex || 0);
        }
    }
    
    // What is the cumulative "flex-value"?
    cum_vflex = vflexes.reduce(function (pv, cv) { return pv + cv; }, 0);
    cum_hflex = hflexes.reduce(function (pv, cv) { return pv + cv; }, 0);
    
    // If no flexes are given; assign each equal
    if (cum_vflex === 0) {
        vflexes.fill(zoof.AUTOFLEX);
        cum_vflex = vflexes.length * zoof.AUTOFLEX;
    }
    if (cum_hflex === 0) {
        hflexes.fill(zoof.AUTOFLEX);
        cum_hflex = hflexes.length * zoof.AUTOFLEX;
    }
    
    // Assign css class and height/weight to cells
    for (i = 0; i < nrows; i += 1) {
        row = table.children[i];
        row.vflex = vflexes[i] || 0;  // Store for use during resizing
        for (j = 0; j < ncols; j += 1) {
            col = row.children[j];
            if ((col === undefined) || (col.children.length === 0)) {
                continue;
            }
            table.applyCellLayout(row, col, vflexes[i], hflexes[j], cum_vflex, cum_hflex);
        }
    }
};


zoof.adaptLayoutToSizeChange = function (event) {
    /* This function adapts the height (in percent) of the flexible rows
    of a layout. This is needed because the percent-height applies to the
    total height of the table. This function is called whenever the
    table resizes, and adjusts the percent-height, taking the available 
    remaining table height into account. This is not necesary for the
    width, since percent-width in colums *does* apply to available width.
    */
    
    var table, row, col, i, j,
        cum_vflex, remainingHeight, remainingPercentage, maxHeight;
    
    table = event.target;
    
    if (event.heightChanged) {
        
        // Set one flex row to max, so that non-flex rows have their minimum size
        // The table can already have been stretched a bit, causing the total row-height
        // in % to not be sufficient from keeping the non-flex rows from growing.
        for (i = 0; i < table.children.length; i += 1) {
            row = table.children[i];
            if (row.vflex > 0) {
                row.style.height = '100%';
                break;
            }
        }
        
        // Get remaining height: subtract height of each non-flex row
        remainingHeight = table.clientHeight;
        cum_vflex = 0;
        for (i = 0; i < table.children.length; i += 1) {
            row = table.children[i];
            cum_vflex += row.vflex;
            if ((row.vflex === 0) && (row.children.length > 0)) {
                remainingHeight -= row.children[0].clientHeight;
            }
        }
        
        // Apply height % for each flex row
        remainingPercentage = 100 * remainingHeight / table.clientHeight;
        for (i = 0; i < table.children.length; i += 1) {
            row = table.children[i];
            if (row.vflex > 0) {
                row.style.height = Math.round(row.vflex / cum_vflex * remainingPercentage) + 1 + '%';
            }
        }
    }
};
</script>
        
    <!--
    <div>
        <input type="text" id="msg" value="message">
        <input type="submit" id="send" value="send" /><br />
    </div>
    -->
    <div id="log" style="display: none;"> LOG:<br><br></div>

<div id='fps' style='position:fixed; top:0px; left:0px; width:80px; height:20px; background:#afa;'> fps</div>
<script>
var timer = {
    tail: 50,  // how many samples to take a measurement on
    showinterval: 1000,  // each x ms show the fps in the log
    elapsed: [],
    lastshow: 0,
    tick: function (now) {
        this.elapsed.push(now);
        this.elapsed = this.elapsed.slice(-this.tail);
        if (now - this.lastshow > this.showinterval) {
            this.lastshow = now;
            var elapsed = (now - (this.elapsed[0] || now)) / 1000;
            var fps = Math.round(this.elapsed.length / elapsed);
            //console.log(fps);
            document.getElementById('fps').innerHTML = fps + ' FPS';
        }
    },
    start: function (now) {
        requestAnimationFrame(timer.start);        
        timer.tick(now);
    }    
};
timer.start()    
</script>
</body>
</html>
